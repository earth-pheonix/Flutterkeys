
static Future<ManifestModel?> downloadSherpaOnnxVoice(ManifestModel voice) async {
  print('downloadSherpaOnnxVoice: starting');
  try {
    final dir = await getApplicationDocumentsDirectory();
    final savePath = "${dir.path}/sherpaOnnx_models";
    final voiceFolder = "$savePath/${voice.id}"; //model dir
    final onnxPath = "$savePath/${voice.id}.onnx"; //model name
    final voicesBin = "$savePath/${voice.id}-voices.bin"; //voices file if kokoro
    final tokenPath = "$savePath/tokens.txt"; //tokens
    final eSpeakNgFolder = "$savePath/eSpeak-ng"; //data dir
    final listOfFst = [];
    final listOfFar = [];
    final listOfLexicon = [];
    final zipPath = "$savePath/${voice.id}.zip";


    await Directory(savePath).create(recursive: true);
    await Directory(voiceFolder).create(recursive: true);
    print('downloadSherpaOnnxVoice: before download URL');
    if (voice.downloadURL == null) return null;
    print('downloadSherpaOnnxVoice: voice.downloadURL != null');
    // Download zip
    final response = await http.get(Uri.parse(voice.downloadURL!));
    final zipFile = File(zipPath);
    await zipFile.writeAsBytes(response.bodyBytes);
    print('downloadSherpaOnnxVoice: got zip');

    // Unzip
    final zipBytes = await zipFile.readAsBytes();
    final inputStream = InputStream(zipBytes);
    final archive = ZipDecoder().decodeBuffer(inputStream);


    print('downloadSherpaOnnxVoice: unzipped');

    for (final file in archive) {
      final filename = file.name;
      
      Uint8List extractBytes(ArchiveFile file) {
        // only files have content to write
        if (!file.isFile) return Uint8List(0);

        final content = file.content;
        if (content == null) return Uint8List(0);

        // common cases
        if (content is Uint8List) return content;
        if (content is List<int>) return Uint8List.fromList(content);

        // archive's InputStream case
        try {
          // InputStream has toUint8List(), but we check at runtime to be safe
          if (content is InputStream) {
            return content.toUint8List();
          }
        } catch (_) {
          // fallthrough to try a dynamic conversion below
        }

        // last resort: try to coerce to List<int>
        try {
          return Uint8List.fromList(List<int>.from(content as Iterable));
        } catch (e) {
          // give up gracefully
          return Uint8List(0);
        }
      }

      // Special handling for .onnx file
      if (file.isFile && filename.toLowerCase().endsWith(".onnx")) {
        final outFile = File(onnxPath);
        await outFile.create(recursive: true);
        await outFile.writeAsBytes(extractBytes(file), flush: true);
        continue;
      }

      // Special handling for voices.bin file
      if (file.isFile &&  filename.toLowerCase().endsWith("voices.bin")) {
        final outFile = File(voicesBin);
        await outFile.create(recursive: true);
        await outFile.writeAsBytes(extractBytes(file), flush: true);
        continue;
      }

      // Special handling for tokens.txt
      if (file.isFile && filename.toLowerCase().endsWith("tokens.txt")) {
        final outFile = File(tokenPath);
        await outFile.create(recursive: true);
        await outFile.writeAsBytes(extractBytes(file), flush: true);
        continue;
      }

      // extraction of fst + list to save
      if (file.isFile &&  filename.toLowerCase().endsWith(".fst")) {
        final fstPaths = "$voiceFolder/$filename";
        if (file.isFile) {
          final outFile = File(fstPaths);
          await outFile.create(recursive: true);
          await outFile.writeAsBytes(extractBytes(file), flush: true);
          listOfFst.add(fstPaths);
        } else {
          await Directory(fstPaths).create(recursive: true);
        }
        continue;
      }

      // extraction of .far + list to save
      if (file.isFile &&  filename.toLowerCase().endsWith(".far")) {
        final farPaths = "$voiceFolder/$filename";
        if (file.isFile) {
          final outFile = File(farPaths);
          await outFile.create(recursive: true);
          await outFile.writeAsBytes(extractBytes(file), flush: true);
          listOfFar.add(farPaths);
        } else {
          await Directory(farPaths).create(recursive: true);
        }
        continue;
      }

      // extraction of lexicon + list to save
      if (filename.toLowerCase().contains("lexicon") && filename.toLowerCase().endsWith(".txt")) {
        final lexPaths = "$voiceFolder/$filename";
        if (file.isFile) {
          final outFile = File(lexPaths);
          await outFile.create(recursive: true);
          await outFile.writeAsBytes(extractBytes(file), flush: true);
          listOfLexicon.add(lexPaths);
        } else {
          await Directory(lexPaths).create(recursive: true);
        }
        continue;
      }

      // extraction of eSpeak folder
      if (filename.toLowerCase().contains("espeak-ng-data/")) {
        // Find the actual relative path inside the espeak folder
        final startIndex = filename.toLowerCase().indexOf("espeak-ng-data/") + "espeak-ng-data/".length;
        final relative = filename.substring(startIndex); // e.g. "phontab"

        final outPath1 = "$eSpeakNgFolder/$relative";

        if (file.isFile) {
          final outFile = File(outPath1);
          await outFile.create(recursive: true);
          await outFile.writeAsBytes(extractBytes(file), flush: true);
        } else {
          await Directory(outPath1).create(recursive: true);
        }
        continue;
      }

      // Normal extraction for all other files
      final outPath = "$voiceFolder/$filename";
      if (file.isFile) {
        final outFile = File(outPath);
        await outFile.create(recursive: true);
        await outFile.writeAsBytes(extractBytes(file), flush: true);
      } else {
        await Directory(outPath).create(recursive: true);
      }
    }

    print('downloadSherpaOnnxVoice: done saving files');

    await zipFile.delete();

    print('downloadSherpaOnnxVoice:  zip deleted');

    voice.modelPath = onnxPath;
    voice.voicesBin = voicesBin;
    voice.ruleFsts = listOfFst.join(", ");
    voice.ruleFars = listOfFar.join(", ");
    voice.lexicon = listOfLexicon.join(", ");
    voice.tokenPath = tokenPath;
    voice.eSpeakPath = eSpeakNgFolder;

    print('model path: ${voice.modelPath}');
    print('voice bin: ${voice.voicesBin}');
    print('voice fsts: ${voice.ruleFsts}');
    print('fars: ${voice.ruleFars}');
    print('lexicon ${voice.lexicon}');
    print('tokens: ${voice.tokenPath}');
    print('e speak ng: ${voice.eSpeakPath}');

    print("SAVED ONNX SIZE = ${File(onnxPath).lengthSync()}");

    print('downloadSherpaOnnxVoice: model updating');

    downloadedSherpaOnnxLanguageVoice.add(voice);
    
    print('downloadSherpaOnnxVoice: adding to downloaded voices');

    if (voice.id != null) {
      downloadedSherpaOnnxLanguageIds.add(voice.id!);

      saveDownloadedSherpaOnnxValue(
        voice.id!,
        voice.modelPath,
        voice.voicesBin,
        voice.ruleFsts,
        voice.ruleFars,
        voice.lexicon,
        voice.tokenPath,
        voice.eSpeakPath,
      );
    }

    savedownloadedSherpaOnnxLanguageVoice(downloadedSherpaOnnxLanguageIds);

    print('downloadSherpaOnnxVoice: save downloaded model info');

    return voice;

  } catch (e) {
    return null;
  }
}

